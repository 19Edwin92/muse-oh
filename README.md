# 국내 전시 커뮤니티 - Muse-O

![MUSE-O브로셔](https://user-images.githubusercontent.com/51357635/236382171-b6eff0b3-c993-4243-876e-b8ac096f507b.png)
## 🏠 [Home Page](https://www.antsori.com)
---
## 🗂️ 목차



---
## 👨🏻‍🎨 프로젝트 소개
#### 국내 유명 전시부터 찾기 힘든 개인전까지 볼 수 있는 전시 커뮤니티!

- MUSE-O는 전시회를 즐기는 사람들을 위해 전시회 기반 커뮤니티 서비스를 제공합니다.
- 개인전을 홍보하기 힘든 작가들을 위해 개인전을 적극적으로 홍보해줍니다.
- 전시에 방문했던 경험을 사람들과 공유할 수 있고 전시에 대한 리뷰를 공유할 수 있습니다.
- 내 전시에 대한 반응, 내 게시글에 대한 반응을 알람을 통해 확인할 수 있습니다.
- 특정 작가와 대화를 나눌 수 있도록 1:1 메시지를 남길 수 있습니다.
---
##  프로젝트 기간

- 2023년 03월 31일 ~ 2023년 05월 12일 (이후 계속될 예정)
---
## 🧑‍💻 팀 구성

[팀 노션 페이지](https://www.notion.so/seungho-white/9-MUSE-O-SA-f7e236258c4f4eb7aa8acff482357f60)

## 💻Stacks

<img width="850" alt="KakaoTalk_20230506_195531355" src="https://user-images.githubusercontent.com/105100315/236620098-ca30c44f-fd9c-439d-bbe1-1a021232d053.png">


### Front End

![HTML5](https://img.shields.io/badge/html5-%23E34F26.svg?style=for-the-badge&logo=html5&logoColor=white) ![Styled Components](https://img.shields.io/badge/styled--components-DB7093?style=for-the-badge&logo=styled-components&logoColor=white)<br />
![JavaScript](https://img.shields.io/badge/javascript-%23323330.svg?style=for-the-badge&logo=javascript&logoColor=%23F7DF1E) ![React](https://img.shields.io/badge/react-%2320232a.svg?style=for-the-badge&logo=react&logoColor=%2361DAFB) 
![ReactQuery](https://img.shields.io/badge/react--querty-ff4154.svg?style=for-the-badge&logo=react-query&logoColor=white) ![Recoil](https://img.shields.io/badge/Recoil-007af4.svg?style=for-the-badge&logo=data:image/svg+xml;base64,PHN2ZyBpZD0iQ2FscXVlXzEiIGRhdGEtbmFtZT0iQ2FscXVlIDEiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgdmlld0JveD0iMCAwIDI1NS4yMSA2MjMuOTEiPjxkZWZzPjxzdHlsZT4uY2xzLTF7ZmlsbDp3aGl0ZX08L3N0eWxlPjwvZGVmcz48cGF0aCBjbGFzcz0iY2xzLTEiIGQ9Im03NC42MiAyNzcuNDYgMS4yNC0uMTMgMzQuNzgtMy4yOC01My40Ny01OC42NkE5Ni40NyA5Ni40NyAwIDAgMSAzMiAxNTAuM0gzYTEyNS4zIDEyNS4zIDAgMCAwIDMyLjggODQuNTdaTTE3Ny4xMyAzNDdsLTM2IDMuNCA1My4zMiA1OC41MUE5Ni40MSA5Ni40MSAwIDAgMSAyMTkuNjMgNDc0aDI4LjkyYTEyNS4yOCAxMjUuMjggMCAwIDAtMzIuNzYtODQuNTdaIi8+PHBhdGggY2xhc3M9ImNscy0xIiBkPSJNMjUzLjY5IDIzMS42OGMtNi4zMy0zMS4zLTMwLjg5LTU0LjA5LTYyLjU3LTU4LjA3bC02LjM1LS43OWE0OS42MSA0OS42MSAwIDAgMS00My4zNS00OS4xM3YtMjBhNTIuNzUgNTIuNzUgMCAxIDAtMjguOTEtLjM2djIwLjM4YTc4LjU2IDc4LjU2IDAgMCAwIDY4LjY1IDc3LjgybDYuMzYuOGMyMy4yNCAyLjkyIDM0Ljc4IDIwIDM3LjgzIDM1LjFzLS45MyAzNS4zMi0yMS4yMiA0N2E3My44MSA3My44MSAwIDAgMS0zMC4wNiA5LjYybC05NS42NiA5YTEwMi40NSAxMDIuNDUgMCAwIDAtNDEuOCAxMy4zOEM5IDMzMi40NS00LjgxIDM2MyAxLjUyIDM5NC4yOXMzMC44OSA1NC4wOCA2Mi41NyA1OC4wNmw2LjM1LjhhNDkuNiA0OS42IDAgMCAxIDQzLjM1IDQ5LjEydjE4YTUyLjc1IDUyLjc1IDAgMSAwIDI4LjkxLjI2di0xOC4yNmE3OC41NSA3OC41NSAwIDAgMC02OC42NS03Ny44MWwtNi4zNi0uOGMtMjMuMjQtMi45Mi0zNC43OC0yMC4wNS0zNy44My0zNS4xMXMuOTMtMzUuMzIgMjEuMjItNDdhNzMuNjggNzMuNjggMCAwIDEgMzAuMDYtOS42M2w5NS42Ni05YTEwMi40NSAxMDIuNDUgMCAwIDAgNDEuOC0xMy4zOGMyNy42NS0xNi4wMiA0MS40LTQ2LjU0IDM1LjA5LTc3Ljg2WiIvPjwvc3ZnPg==&logoColor=white) 
[![Vercel](https://img.shields.io/badge/-Vercel-black?style=flat-square&logo=vercel&logoColor=white)](https://vercel.com/)
[![axios](https://img.shields.io/badge/-axios-1572B6?style=flat-square&logo=axios&logoColor=white)](https://axios-http.com/)


<br />

### Dev tools
<div>
  <img src="https://img.shields.io/badge/Github-181717?style=for-the-badge&logo=GITHUB&logoColor=white"> 
  <img src="https://img.shields.io/badge/VISUAL STUDIO CODE-007ACC?style=for-the-badge&logo=VISUAL STUDIO CODE&logoColor=white"> 
  <img src="https://img.shields.io/badge/Git-F05032?style=for-the-badge&logo=Git&logoColor=white"> 
  <img src="https://img.shields.io/badge/Figma-F24E1E?style=for-the-badge&logo=FIGMA&logoColor=white"> 
  <img src="https://img.shields.io/badge/notion-000000?style=for-the-badge&logo=notion&logoColor=white"> 
</div>



---
## 🛠 기술적 의사결정([WHY?](https://spark-stove-6bf.notion.site/cf6de263fec844ba8c989b4c9a6dd32e))


---

▶ **Axios** (**API Communication)**

- 서버와의 통신에 있어서 RESTfulAPI(HTTP 기반)를 도입하였고, API를 호출할 때 이 부분(HTTP)에 최적화 되어있는 AXIOS 를 도입하게 되었음.
- Axios는 프로미스를 기반으로 구성되었기에 비동기처리에 있어서의 기능이 우수함.
    - 인터셉터를 통해서 통신이 이뤄지기 전에, 요청이 실패했을 때의 처리 등의 구현 등의 비동기 처리를 간편한 기능을 지원
    - 이에 비해서 Fetch API는 콜백함수로 이를 처리해야 하기에 코드 구현의 어려움이 있음

▶ **React-Route-dom (URL Routing, SPA에서의 라우팅 사용)**

- SPA를 통한 CSR을 구현하는 React의 특성에서 페이지 전환이 동적으로 요구됨.
- 라우팅 관련 라이브러리 가운데 react-router-dom은 간단한 사용성, 높은 확장성, 커뮤니티 지원이 뛰어남.
- CSR의 초기 로딩 속도가 느리다는 측면에서 NEXTjs가 활용되고 있지만, 짧은 개발 시간과 교육비용을 고려했을 때 react-router-dom을 채택함.

▶ **ReactQuery, Recoil (StateManagements)**

1️⃣ **MUSE-O 프로젝트에서의 상태관리**

(토글)**컴포넌트에서 사용하는 데이터(상태) 목록 : 잦은 변화와 즉시적 대응과 관련된 데이터 “빨간색”**

- **메인** 
1) **등록된 전시목록**
2) **등록된 아트그램**  
3) **아트그램에 대한 사용자별 응답(스크랩과 좋아요)**
4) **아트그램에 대한 댓글과 대댓글**
- **전시** :  
5) 전시 등록
    
    *  (1) **등록된 전시목록** 
    6) 전시에 대한 사용자별 응답(좋아요, 스크랩, 후기) 
    
- **아트그램** : 
7) 아트그램 등록(이미지, 제목과 내용), 
*  (2) **등록된 아트그램**
*  (3) **아트그램에 대한 사용자별 응답(스크랩과 좋아요)**
*  (4) **아트그램에 대한 댓글과 대댓글**
- **마이페이지** :
    
    8)유저프로필
    
    *  (1) **등록된 전시목록**
    *  (6) **전시에 대한 사용자별 응답(스크랩과 좋아요) → 본인이 작성한 전시** 
    *  (2) **등록된 아트그램** 
    *  (3) **아트그램에 대한 사용자별 응답(스크랩과 좋아요) → 본인이 작성한 아트그램**
    *  (4) **아트그램에 대한 댓글과 대댓글**
    
    8) 알림
    
- 검색
    
    9) 인기게시글
    
    10) 최근 검색을 통해 이용한 게시글 
    

2️⃣ **이를 위한 상태관리 라이브러리의 선택과 과정**

(토글)**리덕스**는 데이터 변화가 작은 상태를 관리할 때 강점

:: 불러오는데 → 리덕스는 로컬메모리 → 비동기처리를 덮어씌움 → “**새로고침 → 초기화**” → 다시 API 호출(반복)
:: API 호출과 별개로, 이 과정을 수반하기 위한 코드의 압박 
:: 동기적   처리 : (Provider) ActionCreate → Initial State → Redusers → configurstore ⇒ “**dispath(Action) → Reduser → configurstore**”
:: 비동기적처리 : (Provider) ActionCreate(GET,POST,DELETE,PATCH) → Initial State → extraReducers → Slice → configureStore⇒ 반복
:: 데이터사용 : useSelectort(state ⇒ state.Slice) 

(토글)**리액트쿼리**는 “**데이터 변화가 잦은**” 상태를 관리할 뿐 아니라, 이 “**데이터를 기반으로 한 커뮤니티를 제공한다는 측면**”에서 강점 

:: 불러와서 → 캐시(로컬메모리)에 저장 → 데이터를 캐싱해서 사용 → “**새로고침 → 초기화가 이뤄지지 않아요**” → 데이터 캐시에서 불러와요 → API호출의 효율
:: 비동기적처리 : (QueryClientProvider) useQuery(queryKey), useMutation(queryClient.invalidateQueries(queryKey)) 
:: 데이터사용 : res.data 를 가지고 바로 사용 

정리를 해보면, **데이터 캐싱에 우수한 “리액트 쿼리” 채택**

1) 프로젝트 내에서의 데이터 사용의 목적과 방향 : 데이터의 잦은 변경과 사용자간의 커뮤니티 경험 제공적 측면에서의 API 호출에 대한 이슈

2) 코드작성의 간결성과 가독성

3) 비동기처리에 최적화 된 다양한 데이터 패칭과 캐싱을 지원함

- useInfiniteQuery() - 무한스크롤을 위한 전용 비동기처리함수
- 데이터패칭에 세부설정의 다양성과 간편성 : retry, refetchOnWindowFocus, enabled 등
- 프로미스 기반의 에러처리의 간편성(onSuccess, onError)

⇒ 저희 프로젝트의 상태를 보았을 때, React Query가 변화가 잦은 상태를 관리하는데 강점이 있다는 점과 이 같은 상황에서 불필요한 API를 최소화하는 비동기 전용 상태관리 라이브러리라는 점에서 고려하게 되었습니다. 뿐만 아니라 React Query가 이 과정에서 개발의 목적과 의도에 따른 다양한 설정을 지원하고 데이터를 캐싱하여 사용하는 부분이 주는 강점, 리액트 쿼리가 주는 코드작성의 간결성과 가독성으로 채택했습니다. 

3️⃣ **이슈발생 : 리액트 쿼리 도입에서 미처 생각하지 못한 상태관리**, (Prop Drilling)단회적으로 불러오는 데이터의 활용과 서버 통신과 무관한 상태 관리 이슈

(토글)**리코일 도입에 대한 고민과 채택**

선택이유(1 - 김재란) :

- 로그인 및 로그아웃 토큰 관리

```jsx
const { mutate } = useMutation({...
},onSuccess: () => {
      const accessToken = cookies.get("access_token");
      setHeaderState({ ...headerStateSearchs });
      setDecodeAccessToken(jwtDecode(accessToken));
      Swal.fire({
        title: "\n로그인 완료하였습니다.",
        focusConfirm: false,
      });
      navigate("/");
    },...)

export const decodeAccessToken = atom({
  key:"decodeAccessToken",
  default:{}
})

// email, nickname, profileImg, userRole, introduction
export const decodeEmail = selector({
  key:"decodeEmail",
  get: ({get})=> {
    const {email} = get(decodeAccessToken)
    return email
  }
})
```

선택이유(2 - 박영찬) :

- 1) **컴포넌트 위치에 대한 상태관리(Boolean)**
- 2) 각 페이지에서 입력되는 **’검색어’의 상태**
    - 특히, RESTfulAPI - GET메서드를 통해서 특정한 정보를 조회할 때 방법중의 하나인 url에 queryString을 기록하여 전달하는 부분에 있어서 전역에서 관리되고 있는 상태가 요구됨.

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/8a599867-5c0e-4339-9991-d8bd2e72c328/Untitled.gif)

- 3) **검색결과에 따라서 받아온 단회적인 ‘데이터’**를 type(exhibition/artgram/user)에 따라서 구분하고, 각 페이지에서 해당 요소를 활용하는 부분에서의 상태관리

![Untitled](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/64075ea4-f26e-4157-911b-6e71cc1da872/Untitled.png)

---

선택이유(3 - 백승호) : 

리코일은 중간에 도입하게 되었다.

Exhibition 페이지에서 최상단 컴포넌트의 params 값을 header에서 검색, 필터를 걸어서 변경하면 페이지에 표시되는 값이 달라지는 메커니즘  있었습니다. 이를 해결하기 위해 header 컴포넌트 내부에 props로 params를 변경하는 함수를 전달해야 했으나, 이로 인해 Prop Drilling 문제가 발생하였습니다.

전체적인 코드를 작성하면서  컴포넌트 재활용을 위해 컴포넌트 분할을 실시하였고, 이로 인해 중간 컴포넌트에서 다시 props로 함수를 전달해야 하는 문제가 생겼습니다. 이를 해결하기 위해 전역 상태 값을 다루는 recoil을 사용하여 최상단 컴포넌트에서 params 값을 전역 상태 값으로 설정하고, 해당 값을 다루는 컴포넌트 내에서만 상태 값을 변경하여 Prop Drilling을 최소화하였습니다.

또 다른 이유로 리코일은  React의 useState 훅과 비슷하게 동작하여 직관적이면서 익숙한 구조를 가지고 있습니다.

그로인한 접근성이 매우 뛰어나 적용 하는데 시간적 비용이 최소화  되었습니다.

![MUSE-O-Chrome-2023-05-05-01-15-09.gif](https://s3-us-west-2.amazonaws.com/secure.notion-static.com/7f0f1d72-e2c6-49a7-9b9e-2a3c77e581aa/MUSE-O-Chrome-2023-05-05-01-15-09.gif)

⭐ **전역상태관리에 대한 프로젝트에서의 도입 : ContextAPI, Redux, Recoil**

1) ContextAPI(내장기능) :  `<Context.Provider value={...}>` 가 하나의 성격마다 있어야 함. 

- 현재 Recoil로 구성한 store가 7개인데, 이를 위해 `Provider` 가 7개 요구됨.
- 상하관계의 컴포넌트밖에는 상태관리를 할 수없다는 측면이 있음

2) Redux : 현업에서 상태관리 라이브러리 부분에서 가장 많이, 그리고 가장 오랫동안 ‘**애증**’의 라이브러리 

- Flux패턴으로 구성된 Redux는 상태관리를 생성하기 위해 ActionCreate → Initial State → Redusers → configurstore 를 생성해야 했음
- 너무나 당연하게, 상태관리 하면 Redux가 정설이었던 현재적 시점

3) **의문제기** : 데이터 부분에 있어서 전체적으로 서버를 의존하고 있는 프로젝트 특성상,
     전역에서 사용할 단순한  몇 가지의 데이터의 상태를 위해서 복잡한 Redux 생태계를 구축해야 하는지에 대한 의문이 발생했음. 

4) **Recoil 도입** : 페이스북에서 만들었고 기존 리액트의 동작방식인 Hook의 형태와 유사하게 동작한다는 측면에서 교육비용의 측면에서 접근성이 용이

- Redux에 비해서 코드 작성이 단순하고, 직관적임(useRecoilState, useRecoilValue; setter 또는 getter만 따로 호출이 가능)
- 상태를 활용하고 조작하는 것이 간편함(atoms, selector)
- **단점** : 대규모 프로젝트에는 소분되어 있는 store로 인해 유지보수적 측면의 어려움이 있기에, 작은 프로젝트에서 유용함

⇒ 위의 흐름에 따라 ReactQuery, Recoil이 상태 관리 라이브러리로 선정됨
# 🎯 트러블슈팅

---

**[FE] 전체 트러블슈팅**

(토글)**이미지에 대한 고민**

- formData 객체를 활용한 서버전달, 서버에서의 이미지처리 탈피
- S3bucket 으로 클라이언트에서 직접 이미지 업로드, 이로인한 이미지처리속도 향상 → 서버의 데이터처리의 빠른 실행
- S3bucket 에 대한 환경변수를 프론트엔드에서 보관하고 있고, 빌드파일에 노출된다는 잠재적 위험성이 있음
- CloudFlare가 비용적인 측면과 환경변수적 측면에서 고려되었지만, formData를 수에 대한 url을 할당받고, 할당url에 formData를 전달하고, 업로드된 url을 전달받아서, 이를 서버로 보낸다는 4번의 과정이 수반됨, 처리속도적인 측면에서 프론트엔드에서 이미지를 업로드하는 이점이 없음.
- 현재 S3bucket 로 이미지를 프론트엔드 개발에서 업로드 하는 방향을 유지하고 있음.

**[FE]** **김재란** 

(토글)📍유효성검사 로직 개선

`주제`

회원가입 페이지나 로그인 페이지에서 input 아래에 유효성검사 내용(경고 메시지)를 어떻게 보여주는 것이 효율적인가

`문제 인지(처음 작성한 방식)`

div 태그 안에 함수를 넣어서 결과를 출력해주는 방식

```jsx
const emailRegExp = /^[a-zA-Z0-9+\-\\_.]+@[a-zA-Z0-9\\-]+\.[a-zA-Z0-9\-.]+$/;

  //이메일 입력값에 따른 검사값 출력
  const emailValidation = () => {
    if (registerInfo.email === "") {
      return "";
    } else if (!emailRegExp.test(registerInfo.email)) {
      return "이메일 형식이 올바르지 않습니다.";
    } else {
      return "";
    }
  };

return
 <div>{emailValidation()}</div>
```

→ 이렇게 작성하면 `emailValidation` 함수가 제대로 작동하지 않거나, 값이 변경되지 않을 경우 함수가 다시 호출되지 않게되어 div 안의 경고 메시지가 변경되지 않거나 잘못 보일 가능성이 높다.

`해결(이전보다 나아진 방식)`

찾아보니 유효성검사 라이브러리가 있었으나, 직접 구현해보고자 하는 열망이 들었다.

그래서 다른 사람들이 작성한 코드를 살펴보고 React에서 제공하는 주요 Hook중 useState에 보여줄 메시지 값을 상태에 따라 다양하게 담아 div태그에 넣는 방식을 사용했다.

그리고 useEffect를 사용하여 변화가 일어날때마다 렌더링해주었다.

아래는 이메일 검사 작성 일부다.

```jsx
const [emailMsg, setEmailMsg] = useState("");

const loginHandler = e => {
    e.preventDefault();
    if (!loginInfo.email) {
      setEmailMsg("이메일을 입력해주세요.");
    } else if (!loginInfo.password) {
      setPwMsg("비밀번호를 입력해주세요.");
    } else {
      login(loginInfo);
    }
  };

//마운트, 빈 값이 아닐경우, 정규식
  useEffect(() => {
    if (registerInfo.email === "") {
      setEmailMsg("");
    } else if (!emailRegExp.test(registerInfo.email)) {
      setEmailMsg("이메일 형식이 맞지 않습니다.");
    } else {
      setEmailMsg("");
    }
  }, [registerInfo.email]);

//return
<div>{emailMsg}</div>
```

이렇게 변경하여 React의 주요 Hook을 사용함으로, React에서 상태를 관리하고 이를 활용해서 동적으로 화면을 업데이트할 수 있게 변경하였다.

`그 이후`

이전보다 나아진 방식이라고 생각하긴 하나, useEffect를 사용하여 변화를 감지하여 보여주는것이 최선인지에 대해 다시 고민하고있다. useEffect 역시 React의 주요 Hook으로 좋은 기능이지만, 좁은 레이아웃 내에서 많은 정보를 입력하고 확인받는 회원가입 페이지에서 사용자가 입력하거나 특정 버튼을 누를때마다 감지되는것은 불필요한 렌더링이 있을 수 있으며 이는 곧 성능 저하로 이어지기 때문이다.

유효성검사 라이브러리를 자세히 살펴보며 어떤 방식으로 구현된 것인지, 혹시 지금 구현한 useEffect보다 좋은 방법이 있는지 보고 또다시 개선해보려 한다.

(토글)📍로그인 후 마이페이지 접속시 프로필 미출력

`문제`

로그인 후 마이페이지에 접속하면 유저 프로필이 출력되지 않는 현상

`원인`

마이페이지로 가면 GET 요청을 함 → Network의 headers를 확인한 결과  `Authorization Bearer undefined`로 요청중인 것을 확인

`해결`

1. 로그인 하기 전, 메인페이지 띄웠을 때 = undefined

2. 로그인 후 쿠키에는 토큰이 저장되어있음

3. 로그인 후 쿠키에 저장시킨 토큰을 get해오는 로직이 없음

⇒ undefined일 경우 interceptors를 사용하여 Cookie에 있는 Token을 다시 get하여 headers에 담아 요청하며 해결

```jsx
// 토큰없이 보낼때
export const apis = axios.create({
  baseURL: process.env.REACT_APP_SERVER_URL,
});

// 토큰 넣어서 보낼때
export const apis_token = axios.create({
  baseURL: process.env.REACT_APP_SERVER_URL,
  headers: {
    Authorization: `Bearer ${token}`,
  },
});

// 해결 *Bearer undefined 처리*
apis_token.interceptors.request.use(config => {
  if (config.headers.Authorization === "Bearer undefined") {
    const token = cookies.get("access_token");
    config.headers.Authorization = `Bearer ${token}`;
		}
		return config;
});
```

// 토큰없이 보낼때
export const apis = axios.create({
baseURL: process.env.REACT_APP_SERVER_URL,
});

// 토큰 넣어서 보낼때
export const apis_token = axios.create({
baseURL: process.env.REACT_APP_SERVER_URL,
headers: {
Authorization: `Bearer ${token}`,
},
});

// 해결 *Bearer undefined 처리*
apis_token.interceptors.request.use(config => {
if (config.headers.Authorization === "Bearer undefined") {
const token = cookies.get("access_token");
config.headers.Authorization = `Bearer ${token}`;
}
return config;
});

`문제`

**[FE] 박영찬**

(토글)📍**첫째**, **검색어의 상태를 다루는** 부분(전역상태관리의 필요성과 리액트쿼리의 쿼리키)

- 프로젝트환경 : 검색어가 입력되는 환경(각각의 **라우터의 헤더컴포넌트**에서 입력 → **검색페이지**로 이동)
- 검색어통신방법 : RESTfulAPI 통신 가운데 GET 방식으로 전달하되, queryString으로 해당요소의 값을 전달
- 문제(1) 검색어의 상태유지
    - 검색어를 전달할 GET메서드의 호출위치(커스텀 훅으로 제작)
        - **GET메서드에 대한 커스텀훅**
            
            ```jsx
            export const useUnifiedSearch = () => {
              const searchWord = useRecoilValue(searchWordState);
              const queryClient = useQueryClient();
              
              const [, setData] = useRecoilState(searchDataState);
              useHeaderState()
              useEffect(() => {
                queryClient.invalidateQueries([keys.GET_UNIFIEDSEARCH, searchWord]);
              }, [searchWord]);
            
              const { isLoading, isError } = useQuery({
                queryKey: [keys.GET_UNIFIEDSEARCH, searchWord],
                queryFn: async () => {
                  const response = await apis_token.get(`/search?searchText=${searchWord}`);
                  return response.data.search;
                },
                refetchOnWindowFocus: false,
                retry: 1,
                onSuccess: (data) => {
                  setData(data);
                },
                onError: (e) => {
                  console.log(e.message);
                },
              });
            
              return { isLoading, isError };
            };
            ```
            
    - 상하위구분이 없는 각각의 컴포넌트(라우터)의 검색어에 대한 상태관리
    - 새로운 검색어가 입력되었을 때의  GET메서드의 호출
    
    해당 문제는 전역에서 관리할 검색어 상태에 대한 이슈를 발생시켰다. React-query를 통해서 비동기적 데이터 상태관리를 하고 있었던 프로젝트의 환경에서는 전역상태관리에 대응하지 못했다.  그 결과 전역에서 관리해야할 코드를 작성해야 했다. 이 부분에 있어서 (상태관리관련 의사결정 - contextAPI, Redux, Recoil) 고민을 했고, Recoil를 도입하였다. 검색어를 입력하고 엔터를 입력하면 form태그의 onSubmit 이 실행되는데, 이때 공백을 제거한 값을 생성한 atoms에 대입시켰다. 그후 라우팅을 통해 검색페이지로 넘어가, GET 메서드가 실행되도록 설정하였다. 
    
- 문제(2) 변경된 검색어에 대한 useQuery의 고유키에 대한 설정 부분의 이슈
    
    해당 이슈는 이전에 대댓글에 대한 조회와 invalidateQueries()를 실행하면서 겪었던 동일한 문제이다. useQuery의 고유키는 고유해야 한다. 이전 사례에서는 고유한쿼리키+게시글id+댓글id로 조합한 키값으로 각각의 대댓글에 대한 입력과 무효화가 가능하도록 접근했다. 이번에도 동일했다.  `keys.GET_UNIFIEDSEARCH` 휴먼에러를 방지하고자 사전에 입력한 설정을 새롭게 생성한 검색어의 쿼리키로 사용하는 것은 불가한 일이기 때문이다. [1] 이에 대해서 먼저 useQuery를 선언할 때 사전에 입력한 설정값+입력된 검색어의 조합으로 된 쿼리키를 생성했다. [2] 그리고 신규입력이야 되겠지만, 새롭게 입력된 검색어에 대해서 대응하기 위해서 useEffect를 통해서 중앙에서 관리중인 검색어의 상태가 변경될 때마다 무효화를 선언함으로 해당 GET이 동작하도록 설정하여 문제에 접근했다. 이 과정에서 React-query가 다루는 상태의 관리(데이터 캐싱)와 이를 가능하게 하는 쿼리키의 중요성에 대해서 깊은 공감과 경험을 할 수 있었다. 
    
- 문제(3) - GET요청에 있어 조건부 비동기 통신 설정
    
    **컴포넌트 마운트와 함께 실행되는 GET메서드에 대한 부분**, 프로젝트에서 데이터의 상태를 관리하는 기술결정으로 리액트쿼리를 채택하였다. 문제는 데이터를 패칭해오는 과정에서 GET요청은 컴포넌트가 마운트될 때 무조건 실행된다는 점이었다. 그러나 이러한 통신은 불필요한 API 호출을 야기한다. 이번 프로젝트에서는 3개의 경우에서 조건부 GET메서드의 실행이 요구되었다. [1] 헤더의 프로필상태이고, [2] 검색어의 인기 게시글 정보 받아오기, [3] 사용자별 최근에 검색어를 통해 검색한 게시글 정보 받아오기 였다. 컴포넌트가 마운트되었을 때 실행되면 안되었고 특정한 조건이 있을 때에만 실행시키고 싶었다. 
    문제 해결 과정은 ChatGPT였다. 물론 공식문서([https://tanstack.com/query/v4/docs/react/reference/useQuery](https://tanstack.com/query/v4/docs/react/reference/useQuery))에서 config에 대한 설정을 읽어보았다면 되었겠지만, 오랜 시간이 걸렸을 것이다.  config 가운데 enabled 라는 설정값이 있다. 이를 통해서 조건에 부합되면 GET메서드를 실행시킬 수 있는 상황을 제어할 수 있었다. 여기서 비동기통신 전용의 데이터 상태관리를 표망한 리액트쿼리의 우수성을 공감할 수 있었다. 이를 활용해서 아래와 같이 전역에서 관리 중인 상태의 값을 구독했고 해당 상태의 값이 존재할 때에만 GET메서드가 실행되도록 코드를 설정함으로 목적에 따른 개발을 실시 할 수 있었다. 이번에 배운 것은 역시 공식문서를 꼼꼼히 읽어보라는 권면은 언제나 옳다는 것이다. 물론 모든 라이브러리들에 원하는 기능이 존재하는 것은 아니지만, 불가능한지와 가능한지의 여부는 살펴볼 수 있게 되는 경험을 가질 수 있기 때문이다. 
    
    ```jsx
    export const useSearchRecent = (searchWindow) => {
      const { isLoading, isError, data } = useQuery({
        queryKey: keys.GET_UNIFIEDSEARCHRECENT,
        queryFn: async () => {
          const response = await apis_token.get("/search/recent");
          return response.data.recentHistory;
        },
        enabled: searchWindow,
        retry: 1,
        refetchOnWindowFocus: false,
        onError: (e) => {
          console.log("error", e.message);
        },
      });
      return { isLoading, isError, data };
    };
    ```
    

(토글)📍둘째, 뷰파트에 대한 이해의 측면(**InterserctionObserver, 이전라우터의 스크롤 위치 기억**)

- 문제발생(1) **InterserctionObserver에 대한 이해부족**에서 발생된 무한스크롤 기능장애
    - 문제를 이해하기 위한 공부(**MDN문서**)
        
        MDN문서에 따르면 **Intersection Observer API**는 감시하고자 하는 요소가 다른 요소(viewport)에 들어가거나 나갈때 또는 요청한 부분만큼 두 요소의 교차부분이 변경될 때 마다 실행될 콜백 함수를 등록할 수 있게 한다. 비록 정확히 몇 픽셀이 겹쳐졌고 어떠한 픽셀이 겹쳐졌는지 Intersection Observer API 가 알려줄 수 없지만 N% 정도 교차할 때를 기점으로 동작하는 원리이다. 
        
        ```jsx
        const observer = new IntersectionObserver(entries => {
              if (entries[0].isIntersecting) {
                // 수행할 동작을 기록하는 공간
              }
            }, { threshold: 1 });
        ```
        
        **IntersectionObserver** 의 기능을 결정하는 것은 `threshold: 1`설정한 설정값이다. 0~1에 따라서 교차범위를 지정할 수 있다. 정확한 이해가 아닐 수도 있지만. 0~100%를 0~1 단계로 값을 축소했다는 느낌을 받았다. 즉 보여지는 뷰파트에 이전에 있었던 요소가 위로 올라가고, 그 다음으로 등장하는 태그에 해당 기능이 설정되어 있으면, 기능이 동작하는 원리이다. 
        
        ```jsx
        function Test() {
          const ref = useRef(null);
        
          useEffect(() => {
            const observer = new IntersectionObserver(entries => {
              if (entries[0].isIntersecting) {
                alert('안녕');
              }
            }, { threshold: 1 });
        
            if (ref.current) {
              observer.observe(ref.current);
            }
        
            return () => {
              if (ref.current) {
                observer.unobserve(ref.current);
              }
            };
          }, []);
        
          return (
        	<div>
        		<div style={{ height: "100vh" }}>위는 빈 화면입니다.</div>
         		<div ref={ref} style={{ height: "100vh" }}>
           			 여기에 스크롤을 내리면 "안녕"이라는 알림이 뜹니다.
                </div>
          </div>
          );
        }
        
        export default Test;
        ```
        
        **useRef(null)** 는 **IntersectionObserver**가 동작할 태그를 참조하기 위해 선언된다. **useEffect**는 컴포넌트가 마운드될 때 관찰을 시작하기 위한 선언과, 언마운트 되었을 때 관찰을 중지하기 위한 선언의 기능을 수행한다. 참조와 관찰의 기능이 동작될 때,  **IntersectionObserver**는 동작을 실행한다. 
        
    - 문제(1) - **“threshold: 값에 대한 이해부족”**
        
        **“threshold: 값에 대한 이해부족”**으로 인해 무한 스크롤 기능이 개발목적에 대응하여 동작하지 않는 이슈가 있었다. 이를 해결하기 위해 **MDN 공식문서**를 참조하였고, 적정한  **threshold** 값을 설정해야 한다는 이해를 할 수 있었습니다. 
        
    - 문제(2) - “**같은컴포넌트에서 새로고침시 동작하지 않는 이슈**”
        
        **라우팅변경시에는 동작, 하지만 같은컴포넌트에서 새로고침시 동작하지 않는 이슈**로 참조(useRef)를 걸었던 대상에 대한 관찰과 관찰해제가 동작하지 않는 이유가 발생했다. 이를 해결하기 위해 **MDN 공식문서**를 기반으로 작성한 **IntersectionObserver**에 대한 코드를 살펴보았지만 특별한 이상은 발견할 수 없었다. 그래서 동일한 컴포넌트를 재작성하면서 혹시라도 내가 놓친 부분이 있는지 살펴보고자 하였고, 재작성을 완료하고(동일한 코드) yarn start를 했을 때 문제가 해결되었다. 추후의 공부에서 혹시 모를 이유를 생각해보았다. 이는 새로고침시 useEffect의 cleanUp 에 문제가 생겼던 것으로 판단된다. **IntersectionObserver**는 새롭게 생성되었지만, useRef가 참고하는 대상에 대한 문제가 발생했던 것은 아닌가이다. 이를 해결하는 방법으로는 useEffect의 의존성 배열을 견고하게 설정하는 것이 될 수도 있을 것이다. [ref]를 추가하여, ref가 변경된 경우에도 대응하도록 한다면 보다 견고한 로직을 구현할 수 있었을 것이다. 이후에 같은 문제가 발생된다면 이러한 접근 방법도 고려해보려 한다. 
        
        이 문제를 해결하며, 해결과정은 공부한 기간에 비해서 단촐하였다. 그렇지만 이 과정에서 **IntersectionObserver**에 대한 이해를 높일 수 있었으며, 이를 통해 동적으로 화면을 구성하는 이점을 발생시킬 수 있다는 것을 깨달았다. 또한, 상시 관찰을 하는 window.addEventListener()와 getBoundingClientRect()로 구현한 이벤트의 문제점(관찰의 피로도 등)과 비교하여, IntersectionObserver의 상대적인 이점을 확인할 수 있었다.
        
- 문제발생(2) **SPA에 있어서 이전 라우터의 스크롤 위치를 기억하고 있는 부분**의 문제 발생
    - 문제 - “**SPA로 구현된 리액트에서의 라우팅 시 발생되는 스크롤 이슈**”
        
        SPA(Single Page Application)을 구현하는 리액트는 페이지 전체를 새로 로드하지 않고, 가상DOM으로 변경된 부분만 컴포넌트를 갈아끼운다. 이런 SPA가 주는 이점은 새로고침이 없어 화면 깜박임이 없다는 것과, CSR을 구현하기에 초기로딩은 느릴 수 있지만, 로딩 후에는 빠른 화면구성이 가능하다는 점이다. 그러나, 이러한 SPA는 일반적으로 이전 페이지의 상태를 유지한다는 점이며, 그 결과 이전 페이지의 스크롤 위치를 기억하고 이를 유지한다는 것이다. 이 문제의 해결을 위해서는 라우터가 변경되었을 때 스크롤의 위치를 초기화 되어야 한다. 
        
        ```jsx
        useEffect(() => {
            window.scrollTo(0, 0); // SPA문제의 한계, 이전 라우터의 스크롤을 기억하고 있는 문제를 해결하고자 함
        }, [])
        ```
        
        문제해결은 새로운 라우터에 대한 컴포넌트가 마운트 되었을 때, 윈도우 객체의 scrollTo 메서드를 통해서 초기화함으로 문제를 해결하였다. 이 과정에서 CSR과 SPA 방식으로 동작하는 리액트 라이브러리에 대한 이해를 조금 심층시킬 수 있었다. react-router-dom 라이브러리의 한계점에 대해서 살펴볼 수 있었다. 해당 라이브러리는 스크롤 위치 초기화와 같은 동작은 제어하지 못한다는 점이다. 물론 useLocation()를 사용해서, pathname 을 획득하고, 이 때마다 useEffect를 동작시켜 문제를 해결할 수 있기하다. 아래의 코드가 바로 이를 적용한 코드이다.이를 Router.js에서 import 함으로 문제를 해결했다. 
        
        ```jsx
        import { useEffect } from "react";
        import { useLocation } from "react-router-dom";
        
        export default function ScrollToTop() {
          const { pathname } = useLocation();
        
          useEffect(() => {
            window.scrollTo(0, 0);
          }, [pathname]);
        
          return null;
        }
        ```
        
    

**[FE] 백승호**

(토글)📍첫째, input type=file 에 접근하기

`상황.`
전시회 수정 페이지 접속시 기존에 올려둔 img file 정보들을 불러와서 File 객체에 넣어 이미지 들을 preview를 표시해 주고 싶다.

`문제.`

input에 접근을 못 한다.  

`원인`

이는 보안상 문제로  웹 브라우저가 사용자의 개인 파일 및 시스템 데이터에 액세스하지 않도록 방지하기 위한 이유다.

만약 웹 브라우저에서 파일 시스템에 직접 접근을 허용한다면, 악성 사용자가 JavaScript 코드를 사용하여 사용자의 파일 시스템에 접근하고, 중요한 파일을 삭제하거나 수정할 수 있다. 

 그렇기 때문에 input이 type이 file일때 랜더링시 file을 따로 지정을 못 해준다.

결론적으로 클라이언트 부분에서 file을 backend로 바로 보내주는 것에 관하여 수정페이지로 접속할때 기존 file을 넣어 file의 preview를 표시해  주고 싶은데 못하고 있는 상황이다.

`✅ 해결`

수정페이지

이미지를 s3에 올리는 방법.

클라이언트에서 s3에 이미지를 올린다 →작성할때 s3 로 올라간 파일의 url을 backend로 보낸다.→get요청을 할때 랜더링을 위한 backend 에서 s3에 올라가 있는 url을 보내준다. →그럼 url를 img preview에 넣어준다.

💭그럼 input type=file에 어떻게 넣는가? file 객체를 못 다루는건 마찬가지 아닌가??

그렇다 하지만 랜더링 할때 preview는 가능하다.  input type=file에 접근하는 이유도  input type=file에 접근하여 file을 넣어주고 들어간 file을 가지고와서 preview를 보여주기함 이었다. 

💡처리한 방법

file preview는 랜더링 되어있다. 하지만 file은 없는 상황이다. 일단 사용자 측면에서 파일이 올라가 있다고 생각하게 한다.

만약 파일 변경없이 수정을 요청한다면 file은 비어 있기 때문에 마찬가지로 프론트앤드에서도 수정하지 않으면 file을 비워서 보내고 수정을 진행한다면 file을 넣고 preview url도 교체가 된다.backend 쪽에서 파일이 변동 없을시 기존에 파일을 유지 하고 file이 존재 한다면  수정된 데이터를 넣는 방식을 사용했다.

(토글)📍둘째, state가 변동사항이 있는지 감지하기

`상황.` 

작성, 수정 페이지에서  templete과 data가 달라졌다면 작성이 되었다고 인지하여 confrim()메서드를 띄워주고 싶다. .

`문제`

```jsx
const templete = {
startDate: "",
},
};
const [exhibition, setExhibition] = useState(templete );
```

여기서 templete과 exhibition을 비교해서 exhibition 값이 달라졌다면 confrim()메서드를 띄워주고 싶었다

templete이 초기값 ,exhibition은 나중에 사용자가 입력하면 달라지는값이고

하지만 아무것도 입력 안했을때도 templete과 exhibition이 다르다고 나온다 

`해결 .`

`JSON.Stringify()` 메서드를 사용하여 **`templete`**과 **`exhibition`**을 각각 문자열로 변환한 후, 문자열을 비교하여 두 객체의 내용이 같은지를 확인

**templete**과 **exhibition**이 초기값으로 같은 객체를 참조하고 있기 때문에, **exhibition**
의 상태가 변경되면 **templete**과는 별개의 객체로 새로운 상태가 생성됩니다. 즉 깊은 복사를 실행 했다.

그렇기 때문에 **templete** & **exhibition**은 서로 다른 객체로 인식되고, 값이 같더라도 JavaScript에서 객체 간의 비교는 참조(Reference)에 의한 비교가 이루어지기 때문에, 두 객체가 다르다고 판단된다.

이를 해결하려면 객체의 내용을 비교하는 로직을 추가하여 객체의 내용이 동일한지 비교한다.

```jsx
const changeOnOff = (event) => {
    const { name } = event.target;
    if (
      exhibitionKind !== name &&
      JSON.stringify(templete) !== JSON.stringify(exhibition)
    ) {
      if (window.confirm("기존데이터가 삭제 됩니다.정말로 진행하시겠습니까?")) {
        setExhibitionKind(name);
        setExhibition(templete);
      }
    } else {
      setExhibitionKind(name);
    }
  };
```

값이 작성이 안될때 그냥 confirm() 없이 화면이 전환 되는 로직.

# 👥 팀원 소개

---

| 역할 | 이름 | GitHub | 분담 |
| --- | --- | --- | --- |
| FE 👑 | 백승호 | https://github.com/seunghowhite | 전시 페이지  |
| FE | 김재란 | https://github.com/gitjaeran | 로그인 페이지, 회원가입 페이지, 마이페이지 |
| FE | 박영찬 | https://github.com/19Edwin92 | 메인(헤더포함) 페이지, 아트그램 페이지, 통합검색 페이지 |
| BE 👑 | 임건 | https://github.com/WoogLim |  |
| BE | 김다빈 | https://github.com/dabeenkim |  |
| BE | 문서아 | https://github.com/mseoa |  |
| DE | 강혜린 |  | 디자인 |

